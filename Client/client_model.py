import pandas as pd
import numpy as np
import math
import sys


class User:
    """
    input: root_ids -> String list: a set of song ids used for initial nodes in each cluster
    output: None
    purpose: Simulates a user and tracks their song preferences through a series of Node objects
    User objects also track the batch of song ids they have been assigned as well as the cluster index
    that they are currently in.
    """
    def __init__(self, root_ids):
        self.song_set = set() # list of used id's
        root_list = []
        for id in root_ids:
            root_node = Node(id)
            root_node.ratio = 0
            self.song_set.add(id)
            root_list.append(root_node)
        self.batch = []
        self.root_list = root_list
        self.root_index = 0
          

    # Updates the user with a new batch of size 2 or max_size from the server
    # Returns the information necessary for knn request: node, k, k_lower
    def request_batch(self, max_size):
        """
        input: max_size -> int: the maximum size of the requested batch
        output: request_node -> Node: the node object housing the song_id intended for batch generation
                k -> int: the number of songs the knn request should generate
                k_lower -> int: the lower bound for songs generated by the knn
        purpose: returns the necessary parameters for generating a new batch for this user
        """
        curr_root = self.root_list[self.root_index]
        ratio, request_node, garbage = find_top_ratio(curr_root, None, 0, None)
        if ratio == sys.maxsize:  # the selected node has not been used yet
            # self.get_knn(request_node, 2)
            return request_node, 2, request_node.k_lower
        else:
            # self.get_knn(request_node, max_size)
            return request_node, max_size, request_node.k_lower
        return None

    def evaluate_batch(self, like_data):
        """
        input: like_data -> int list: the user's opinion of each song in the current batch.
                {-1, 0, 1} = {dislike, neutral, like}
        output: return_index -> int: the index of the cluster the user just exited
                song_id -> String: the song id of the node with the best ratio used for updating the server
                None: returns nothing if the user should remain in the current cluster
        purpose: applies the likes and dislikes provided by the user to the node objects in their preference tree.
                 If a user should exit the current cluster due to zero likes being received, proceeds to the next
                 cluster and outputs the information necessary for generating the next batch.
        """
        # builds cluster interest graph from liked songs and updates nodes appropriately
        ratio, root, garbage = find_top_ratio(self.root_list[self.root_index], None, 0, None)
        likes = 0
        for i in range(len(self.batch)):
            if like_data[i] == 1:
                likes += 1
                node = Node(self.batch[i])
                root.add_like()
                root.add_child(node)
                node.add_child(root)
            if like_data[i] == -1:
                root.add_dislike()
            if like_data[i] == 0:
                continue

        # if no songs were liked and the node has been explored before, proceeds to exit the cluster
        if likes == 0 and len(self.batch) > 2:
            top_ratio, top_node, garbage = find_top_ratio(self.root_list[self.root_index], None, 0, None)
            self.root_list[self.root_index] = top_node
            return_index = self.root_index
            self.root_index += 1
            return return_index, top_node.song_id

        return None

    def filter_duplicates(self, cur_candidates):
        """
        input: cur_candidates -> String list: the batch of song ids received from the server
        output: batch -> String list: the set of song ids provided in the input with songs previously
                seen by the user removed
        purpose: helper method to remove song ids previously seen by this user
        """
        batch = []
        for song_id in cur_candidates:
            if song_id not in self.song_set:
                batch.append(song_id)
            #self.song_set.add(song_id)
        return batch

    def add_songs_to_set(self, batch):
        """
        input: batch -> String list: a batch of song ids seen by the user
        output: None
        purpose: adds the song ids given to a set used to filter duplicates
        """
        for song_id in batch:
            self.song_set.add(song_id)

    def filter_batch(self, request_node, candidates):
        """
        input: request_node -> Node: the Node used to generate the KNN request
               candidates -> String list: the batch of song ids received from the server
        output: batch -> String list: the set of song ids provided in the input with songs previously
                seen by the user removed
        purpose: Removes song ids previously seen by this user and increments the lower bound of the Node used for
                 generation to avoid future duplicates
        """
        batch = self.filter_duplicates(candidates)
        request_node.k_lower += len(candidates) - len(batch)
        request_node.increment_k_bound(request_node.k_lower)
        self.batch = batch
        return batch


class Node:
    """
    input: song_id -> String: the song id of a song to represent
    output: None
    purpose: Creates a Node object used for tracking user preference. Represents a single song in a cluster and
             tracks information on neighboring nodes, likes, and dislikes from songs generated when using this song as
             the basis for recommendation
    """
    def __init__(self, song_id):
        self.song_id = song_id

        self.k_lower = 0
        self.neighbors = []

        self.likes = 1
        self.dislikes = 1
        self.ratio = sys.maxsize

    def get_id(self):
        return self.song_id

    def get_neighbors(self):
        return self.neighbors

    def add_child(self, child):
        self.neighbors.append(child)

    def add_like(self):
        self.likes += 1
        if self.dislikes != 0:
            self.ratio = self.likes / self.dislikes

    def add_dislike(self):
        self.dislikes += 1
        if self.dislikes != 0:
            self.ratio = self.likes / self.dislikes

    def increment_k_bound(self, k):
        self.k_lower += k

    def get_k_bound(self):
        return self.k_lower

    def get_ratio(self):
        return self.ratio


def find_top_ratio(root, curr_best_node, curr_best_ratio, used_nodes):
    """
    Recursive method
    input: root -> Node: a node to examine for finding the best ratio in a node graph
           curr_best_node -> Node: the node that currently houses the highest ratio
           curr_best_ratio -> int: the highest ratio found during graph traversal
           used_nodes -> set(Node): a set of nodes previously traversed by this method
    output: curr_best_node -> Node: the node that currently houses the highest ratio found
            curr_best_ratio -> int: the highest ratio found during graph traversal
            used_nodes -> set(Node): a set of nodes previously traversed by this method
    purpose: traverses all nodes linked to the original node to find the node with the highest ratio
    """
    # initial run
    if not used_nodes:
        used_nodes = set()
        used_nodes.add(root)
        curr_best_node = root
        curr_best_ratio = root.ratio

    # evaluates the current node
    if root.ratio > curr_best_ratio and not used_nodes.issuperset({root}):
        curr_best_node = root
        curr_best_ratio = root.ratio
    used_nodes.add(root)

    # evaluates current node's children
    if root.get_neighbors() is not None:
        for child in root.get_neighbors():
            # if a child existsOsCIWrLyYSo
            if not used_nodes.issuperset({child}):
                curr_best_ratio, curr_best_node, used_nodes = find_top_ratio(child, curr_best_node, curr_best_ratio, used_nodes)

    return curr_best_ratio, curr_best_node, used_nodes 
